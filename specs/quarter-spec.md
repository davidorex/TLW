# Quarter Model Specification

### Base Configuration
```python
from core.models.abstracts import MetadataModel
from calendar.models import Term
from django.utils.translation import gettext_lazy as _

Location: calendar/models/quarter.py

Required Only For:
- Semester-based years
- Two quarters per semester
```

### Model Definition
```python
class Quarter(MetadataModel):
    """
    Represents quarter periods within semesters.
    Auto-generated by Term for semester structure.
    Not used in trimester system.
    """

    QUARTER_TYPES = [
        ('Q1', _('First Quarter')),
        ('Q2', _('Second Quarter')),
        ('Q3', _('Third Quarter')),
        ('Q4', _('Fourth Quarter'))
    ]

    METADATA_SCHEMA = {
        "type": "object",
        "properties": {
            "reporting_dates": {
                "type": "object",
                "properties": {
                    "grades_due": {"type": "string", "format": "date"},
                    "reports_due": {"type": "string", "format": "date"},
                    "publish_date": {"type": "string", "format": "date"}
                }
            },
            "assessment_weeks": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "week_number": {"type": "integer"},
                        "assessment_type": {"type": "string"}
                    }
                }
            }
        }
    }

Fields:
- term: ForeignKey
    to=Term
    on_delete=PROTECT
    related_name='quarters'
    help_text="Parent semester term"
    validators=[validate_semester_term]

- quarter_type: CharField
    max_length=2
    choices=QUARTER_TYPES
    db_index=True
    help_text="Quarter designation (Q1-Q4)"

- sequence: IntegerField
    validators=[MinValueValidator(1), MaxValueValidator(2)]
    help_text="Sequence within semester (1-2)"

- start_date: DateField
    db_index=True
    help_text="First day of quarter"

- end_date: DateField
    db_index=True
    help_text="Last day of quarter"

Inherits from MetadataModel:
- Standard tracking fields
- Metadata with schema
- History tracking
```

### Custom Managers
```python
class QuarterManager(models.Manager):
    """Primary manager for Quarter"""
    
    def for_semester(self, term):
        """Returns ordered quarters for a semester"""
        return self.filter(term=term).order_by('sequence')
    
    def get_for_date(self, date):
        """Returns active quarter for date"""
        cache_key = f'quarter:for_date:{date}'
        # Implementation...
```

### Required Methods
```python
class Quarter(MetadataModel):
    # Continue class from above...

    def clean(self):
        """
        Validates:
        1. Parent term is semester
        2. Date range within term
        3. Non-overlapping within term
        4. Valid sequence (1-2)
        5. Metadata schema
        """

    def get_week_number(self, date):
        """
        Returns 1-based week number within quarter.
        Considers term breaks.
        """

    def get_reporting_deadlines(self):
        """
        Returns reporting dates from metadata.
        Used for dashboard alerts.
        """

    @property
    def semester_number(self):
        """1 or 2 based on parent term"""
        
    @property
    def full_label(self):
        """e.g., 'Q1 (S1)' for display"""

    class Meta:
        verbose_name = _("Quarter")
        verbose_name_plural = _("Quarters")
        ordering = ['term', 'sequence']
        unique_together = [
            ['term', 'sequence'],
            ['term', 'quarter_type']
        ]
        indexes = [
            models.Index(fields=['start_date', 'end_date']),
            models.Index(fields=['term', 'sequence'])
        ]
        constraints = [
            models.CheckConstraint(
                check=Q(end_date__gt=F('start_date')),
                name='valid_quarter_dates'
            ),
            models.CheckConstraint(
                check=Q(term__term_type__startswith='SEM'),
                name='quarter_requires_semester'
            )
        ]
```

### Signals
```python
@receiver(pre_save, sender=Quarter)
def validate_term_type(sender, instance, **kwargs):
    """Ensures parent is semester term"""
    if not instance.term.term_type.startswith('SEM'):
        raise ValidationError(_("Quarters only valid for semesters"))

@receiver(pre_save, sender=Quarter)
def validate_dates(sender, instance, **kwargs):
    """Ensures dates within term bounds"""
```

### Caching
```python
CACHE_KEYS = {
    'quarter_weeks': 'quarter:{id}:weeks',
    'quarter_for_date': 'quarter:date:{date}',
    'term_quarters': 'term:{term_id}:quarters'
}

Cache Invalidation:
- save() method
- date transitions
- term changes
- metadata updates
```

### Required Tests
```python
class QuarterTests(TestCase):
    """
    Test suite must cover:
    1. Creation & Validation:
       - Semester requirement
       - Date boundaries
       - Sequence validity
       - Non-overlap
    
    2. Business Rules:
       - Two per semester
       - Proper splitting
       - Metadata handling
    
    3. Week Calculations:
       - Week numbering
       - Boundary cases
       - Term breaks
    
    4. Integration:
       - Term relationship
       - Year access
       - Reporting dates
    
    5. Caching:
       - Week caching
       - Date lookups
       - Invalidation
    """
```

### Factories
```python
class QuarterFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = 'calendar.Quarter'
    
    term = factory.SubFactory(
        TermFactory,
        term_type='SEM1'  # Ensure semester
    )
    sequence = factory.Iterator([1, 2])
    quarter_type = factory.LazyAttribute(
        lambda o: f"Q{o.sequence + ((o.term.sequence-1) * 2)}"
    )
    
    @factory.lazy_attribute
    def start_date(self):
        """Calculate based on term dates and sequence"""
        term_duration = (self.term.end_date - self.term.start_date).days
        quarter_duration = term_duration // 2
        offset = (self.sequence - 1) * quarter_duration
        return self.term.start_date + timedelta(days=offset)

    @factory.lazy_attribute
    def end_date(self):
        """Calculate based on start_date"""
        if self.sequence == 2:
            return self.term.end_date
        term_duration = (self.term.end_date - self.term.start_date).days
        return self.start_date + timedelta(days=(term_duration // 2) - 1)
```

Want me to continue with the PeriodTemplate model specification next?