# Term Model Specification

### Base Configuration
```python
from core.models.abstracts import MetadataModel
from schoolcalendar.models import SchoolYear
from django.utils.translation import gettext_lazy as _

Location: calendar/models/term.py
```

### Model Definition
```python
class Term(MetadataModel):
    """
    Represents major academic periods (semester/trimester).
    Auto-generated by SchoolYear.
    Controls quarter generation for semesters.
    """

    TERM_TYPES = [
        ('SEM1', _('First Semester')),
        ('SEM2', _('Second Semester')),
        ('TRI1', _('First Trimester')),
        ('TRI2', _('Second Trimester')),
        ('TRI3', _('Third Trimester'))
    ]

    METADATA_SCHEMA = {
        "type": "object",
        "properties": {
            "academic_weeks": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "week_number": {"type": "integer"},
                        "start_date": {"type": "string", "format": "date"},
                        "end_date": {"type": "string", "format": "date"}
                    }
                }
            },
            "special_dates": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "date": {"type": "string", "format": "date"},
                        "description": {"type": "string"}
                    }
                }
            }
        }
    }

Fields:
- year: ForeignKey
    to=SchoolYear
    on_delete=PROTECT
    related_name='terms'
    help_text="Associated academic year"

- term_type: CharField
    max_length=4
    choices=TERM_TYPES
    db_index=True
    help_text="Type and sequence of term"

- sequence: IntegerField
    validators=[MinValueValidator(1)]
    help_text="Order within year (1-based)"

- start_date: DateField
    db_index=True
    help_text="First day of term"

- end_date: DateField
    db_index=True
    help_text="Last day of term"

Inherits from MetadataModel:
- id (UUID)
- is_active (soft delete)
- created_at/modified_at
- created_by/modified_by
- metadata (with schema)
- history tracking
```

### Custom Managers
```python
class TermManager(models.Manager):
    """Primary manager for Term"""
    
    def get_for_date(self, date):
        """Returns active term containing date"""
        cache_key = f'term:for_date:{date}'
        # Implementation...

    def get_current(self):
        """Returns currently active term"""
```

### Required Methods
```python
class Term(MetadataModel):
    # Continue class from above...

    def clean(self):
        """
        Validates:
        1. Date range within year
        2. Non-overlapping with other terms
        3. Correct sequence for type
        4. Metadata schema
        """

    def generate_quarters(self):
        """
        Creates quarters if semester.
        Called via post_save.
        Splits term duration evenly.
        """

    def get_week_number(self, date):
        """
        Returns 1-based week number within term.
        Uses cached week boundaries.
        """

    def get_weeks(self):
        """
        Returns list of week date ranges.
        Used for calendar display.
        Cached at term level.
        """

    @property
    def is_current(self):
        """True if today falls within term"""

    @property
    def duration_weeks(self):
        """Number of teaching weeks"""

    class Meta:
        verbose_name = _("Term")
        verbose_name_plural = _("Terms")
        ordering = ['year', 'sequence']
        unique_together = [
            ['year', 'sequence'],
            ['year', 'term_type']
        ]
        indexes = [
            models.Index(fields=['start_date', 'end_date']),
            models.Index(fields=['year', 'sequence'])
        ]
        constraints = [
            models.CheckConstraint(
                check=Q(end_date__gt=F('start_date')),
                name='valid_term_dates'
            )
        ]
```

### Signals
```python
@receiver(post_save, sender=Term)
def ensure_quarters(sender, instance, created, **kwargs):
    """Creates quarters for semester terms"""
    if created and instance.term_type.startswith('SEM'):
        transaction.on_commit(
            lambda: instance.generate_quarters()
        )

@receiver(pre_save, sender=Term)
def validate_dates(sender, instance, **kwargs):
    """Ensures dates within year bounds"""
```

### Caching
```python
CACHE_KEYS = {
    'term_weeks': 'term:{id}:weeks',
    'term_for_date': 'term:date:{date}',
    'current_term': 'term:current'
}

Cache Invalidation:
- save() method
- date transitions
- quarter changes
- metadata updates
```

### Required Tests
```python
class TermTests(TestCase):
    """
    Test suite must cover:
    1. Creation & Validation:
       - Date ranges
       - Sequences
       - Term types
       - Year boundaries
    
    2. Quarter Generation:
       - Semester splitting
       - Date calculations
       - Metadata handling
    
    3. Week Calculations:
       - Week numbering
       - Week boundaries
       - Special dates
    
    4. Integration:
       - Year relationship
       - Quarter cascade
       - Schedule impact
    
    5. Caching:
       - Week caching
       - Date lookups
       - Invalidation
    """

class TermFactoryTests(TestCase):
    """
    Factory test coverage for:
    - Basic term creation
    - With quarters
    - Date variations
    - Metadata patterns
    """
```

### Factories
```python
class TermFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = 'calendar.Term'
    
    year = factory.SubFactory(SchoolYearFactory)
    sequence = factory.Sequence(lambda n: n + 1)
    term_type = factory.LazyAttribute(
        lambda o: f"{'SEM' if o.year.term_structure == 'SEMESTER' else 'TRI'}{o.sequence}"
    )
    # Date calculations based on year dates...

class TermWithQuartersFactory(TermFactory):
    """Ensures quarters exist for semesters"""
    
    @factory.post_generation
    def with_quarters(obj, create, extracted, **kwargs):
        if create and obj.term_type.startswith('SEM'):
            obj.generate_quarters()
```

Want me to continue with the Quarter model specification next?